// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package org.apache.impala.catalog;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.util.concurrent.ThreadFactoryBuilder;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import org.apache.hadoop.hive.metastore.api.CurrentNotificationEventId;
import org.apache.hadoop.hive.metastore.api.NotificationEvent;
import org.apache.hadoop.hive.metastore.api.NotificationEventResponse;
import org.apache.hadoop.hive.metastore.messaging.MessageFactory;
import org.apache.hadoop.hive.metastore.messaging.json.ExtendedJSONMessageFactory;
import org.apache.impala.catalog.MetaStoreClientPool.MetaStoreClient;
import org.apache.impala.catalog.MetastoreEventHandlerUtils.MetastoreEventHandlerFactory;
import org.apache.impala.common.ImpalaException;
import org.apache.log4j.Logger;
import org.apache.thrift.TException;

/**
 * A metastore event is a instance of the class
 * <code>org.apache.hadoop.hive.metastore.api.NotificationEvent</code>. Metastore can be
 * configured, to work with Listeners which are called on various DDL operations like
 * create/alter/drop operations on database, table, partition etc. Each event has a unique
 * incremental id and the generated events are be fetched from Metastore to get
 * incremental updates to the metadata stored in Hive metastore using the the public API
 * <code>get_next_notification</code> These events could be generated by external
 * Metastore clients like Apache Hive or Apache Spark as well as other Impala clusters
 * configured to talk with the same metastore.
 *
 * This class is used to poll metastore for such events at a given frequency. By applying
 * such events on the catalogD we can sync to external metadata operations by taking
 * appropriate actions for each event type. We keep track of the last synced event id in
 * each polling iteration so the next batch can be requested appropriately. The current
 * batch size is constant and set to MAX_EVENTS_PER_RPC.
 *
 *      +---------------+   +----------------+        +--------------+
 *      |Catalog state  |   |Catalog         |        |              |
 *      |stale          |   |State up-to-date|        |Catalog state |
 *      |(apply event)  |   |(ignore)        |        |is newer than |
 *      |               |   |                |        |event         |
 *      |               |   |                |        |(ignore)      |
 *      +------+--------+   +-----+----------+        +-+------------+
 *             |                  |                     |
 *             |                  |                     |
 *             |                  |                     |
 *             |                  |                     |
 *             |                  |                     |
 * +-----------V------------------V---------------------V----------->  Event Timeline
 *                                ^
 *                                |
 *                                |
 *                                |
 *                                |
 *                                E
 *
 * Consistency model: Events could be seen as DDLs operations from past either done from
 * this same cluster or some other external system. For example in the events timeline
 * given above, consider a Event E at any given time. The catalog state for the
 * corresponding object of the event could either be stale, exactly-same or at a
 * version which is higher than one provided by event. Catalog state should only be
 * updated when it is stale with respect to the event. In order to determine if the
 * catalog object is stale, we rely on a combination of creationTime and object version
 * . A object in catalog is stale if and only if its creationTime is <= creationTime of
 * the object from event AND its version < version from event.
 *
 * If the object has the same createTime and version when compared to event or if the
 * createTime > createTime from the event, the event can be safely ignored.
 *
 * Following table shows the actions to be taken when the catalog state is stale.
 *
 *               +----------------------------------------+
 *               |    Catalog object state                |
 * +----------------------------+------------+------------+
 * | Event type  | Loaded       | Incomplete | Not present|
 * |             |              |            |            |
 * +------------------------------------------------------+
 * |             |              |            |            |
 * | CREATE EVENT| removeAndAdd | Ignore     | Add        |
 * |             |              |            |            |
 * |             |              |            |            |
 * | ALTER EVENT | Invalidate   | Ignore     | Ignore     |
 * |             |              |            |            |
 * |             |              |            |            |
 * | DROP EVENT  | Remove       | Remove     | Ignore     |
 * |             |              |            |            |
 * +-------------+--------------+------------+------------+
 *
 * //TODO - Object version support is a work-in-progress in Hive. Current event
 * handlers only rely on createTime on Table and Partition. Database createTime is a
 * work-in-progress in Hive in (HIVE-20776)
 *
 * All the operations which change the state of catalog cache while processing a
 * certain event type must be atomic in nature. We rely on taking a write lock on
 * version object in CatalogServiceCatalog to make sure that readers are blocked while
 * the metadata update operation is being performed. Since the events are generated
 * post-metastore operations, such catalog updates do not need to update the state in
 * Hive Metastore. Additionally, in case of errors during event processing or catalog
 * updates, it is safe to ignore the event since the subsequent events on that same
 * object will make sure that the catalog is stale before applying any such event.
 *
 */
public class MetastoreEventsProcessor {
  public static final String METASTORE_NOTIFICATIONS_ADD_THRIFT_OBJECTS_CONFIG_KEY =
      "hive.metastore.notifications.add.thrift.objects";
  private static final Logger LOG = Logger.getLogger(MetastoreEventsProcessor.class);
  // Use ExtendedJSONMessageFactory to deserialize the event messages.
  // ExtendedJSONMessageFactory adds additional information over JSONMessageFactory so
  // that events are compatible with Sentry
  // TODO this should be moved to JSONMessageFactory when Sentry switches to
  // JSONMessageFactory
  private static final MessageFactory messageFactory =
      ExtendedJSONMessageFactory.getInstance();

  private static MetastoreEventsProcessor INSTANCE;

  // maximum number of events to poll in each RPC
  private static final int EVENTS_BATCH_SIZE_PER_RPC = 1000;

  // default event handler key
  private static final String DEFAULT_EVENT_HANDLER_KEY = "default";

  // eventHandler factory which is used to get or create eventHandlers
  private final MetastoreEventHandlerFactory eventHandlerFactory_;

  // keeps track of the last event id which we have synced to
  private long lastSyncedEventId_;

  // polling interval in seconds. Note this is a time we wait AFTER each fetch call
  private final long pollingFrequencyInSec_;

  // keeps track if the polling has be started or not
  private boolean isInitialized_;

  // catalog service instance to be used while processing events
  private final CatalogServiceCatalog catalog_;

  // scheduler daemon thread executor for processing events at given frequency
  private final ScheduledExecutorService scheduler_ =
      Executors.newSingleThreadScheduledExecutor(
          new ThreadFactoryBuilder()
              .setDaemon(true)
              .setNameFormat("MetastoreEventsProcessor")
              .build());

  private MetastoreEventsProcessor(
      CatalogServiceCatalog catalog, long startSyncFromId, long pollingFrequencyInSec) {
    Preconditions.checkState(pollingFrequencyInSec >= 0);
    this.catalog_ = Preconditions.checkNotNull(catalog);
    // this assumes that when MetastoreEventsProcessor is created, catalogD just came
    // up in which case it already is going to do a full-sync with HMS
    // TODO figure out if CatalogD sync with HMS is in-process or completed so that we
    // know  if we need to ignore some of events which are already applied in catalogD
    lastSyncedEventId_ = startSyncFromId;
    eventHandlerFactory_ = new MetastoreEventHandlerFactory(catalog_);
    pollingFrequencyInSec_ = pollingFrequencyInSec;
  }

  /**
   * Schedules the daemon thread at a given frequency. It is important to note that this
   * method schedules with FixedDelay instead of FixedRate. The reason it is scheduled at
   * a fixedDelay is to make sure that we don't pile up the pending tasks in case each
   * polling operation is taking longer than the given frequency. Because of the fixed
   * delay, the new poll operation is scheduled at the time when previousPoll operation
   * completes + givenDelayInSec
   */
  public synchronized void start() {
    if (isInitialized_) {
      LOG.warn(String.format("Event processing is already started with a polling "
              + "interval of %d seconds",
          pollingFrequencyInSec_));
      return;
    }
    Preconditions.checkState(pollingFrequencyInSec_ > 0);
    LOG.info(String.format("Starting metastore event polling with interval %d seconds.",
        pollingFrequencyInSec_));
    scheduler_.scheduleWithFixedDelay(() -> {
      try {
        processHMSNotificationEvents();
      } catch (ImpalaException e) {
        LOG.error(
            String.format(
                "Unexpected exception %s received while processing metastore events",
                e.getMessage()),
            e);
      }
    }, pollingFrequencyInSec_, pollingFrequencyInSec_, TimeUnit.SECONDS);

    isInitialized_ = true;
  }

  /**
   * This method issues a request to Hive Metastore if needed, based on the current event
   * id in metastore and the last synced event_id. Events are fetched in fixed sized
   * batches.
   */
  @VisibleForTesting
  void processHMSNotificationEvents() throws ImpalaException {
    NotificationEventResponse response;
    try (MetaStoreClient msClient = catalog_.getMetaStoreClient()) {
      // fetch the current notification event id. We assume that the polling interval
      // is small enough that most of these polling operations result in zero new
      // events. In such a case, fetching current notification event id is much faster
      // (and cheaper on HMS side) instead of polling for events directly
      CurrentNotificationEventId currentNotificationEventId =
          msClient.getHiveClient().getCurrentNotificationEventId();
      long currentEventId = currentNotificationEventId.getEventId();

      // no new events since we last polled; return
      if (currentEventId <= lastSyncedEventId_) return;

      response = msClient.getHiveClient().getNextNotification(
          lastSyncedEventId_, EVENTS_BATCH_SIZE_PER_RPC, null);
      LOG.info(String.format("Received %d events. Start event id : %d",
          response.getEvents().size(), lastSyncedEventId_));
    } catch (TException e) {
      throw new MetastoreNotificationException(
          "Unable to fetch notifications from metastore. Last synced event id is "
              + lastSyncedEventId_,
          e);
    }
    for (NotificationEvent event : response.getEvents()) {
      try {
        eventHandlerFactory_.getOrCreate(event.getEventType()).process(event);
      } catch (MetastoreNotificationException ex) {
        LOG.warn(String.format(
            "Unable to process notification event %d due to %s. Ignoring this event...",
            event.getEventId(), ex.getMessage()));
        dumpEventInfoOnErrors(event);
      } finally {
        // Make sure to update lastSyncedEventId_ in case there are errors while
        // processing the event. Otherwise, the sync thread will be stuck forever at
        // this bad event and keep throwing exception until catalogD is restarted
        lastSyncedEventId_ = event.getEventId();
      }
    }
  }

  private void dumpEventInfoOnErrors(NotificationEvent event) {
    StringBuilder msg = new StringBuilder("Error while processing following event : "
        + "\n")
                            .append("Event id : " + event.getEventId() + "\n")
                            .append("Event Type : " + event.getEventType() + "\n")
                            .append("Event time : " + event.getEventTime() + "\n")
                            .append("Database name : " + event.getDbName() + "\n");
    if (event.getTableName() != null) {
      msg.append("Table name : " + event.getTableName() + "\n");
    }
    msg.append("Event message : " + event.getMessage() + "\n");
    LOG.error(msg.toString());
  }

  /**
   * Create a instance of this object if it is not initialized. Currently, this object is
   * a singleton and should only be created during catalogD initialization time, so that
   * the start syncId matches with the catalogD startup time.
   *
   * @param catalog the CatalogServiceCatalog instance to which this event processing
   *     belongs
   * @param startSyncFromId Start event id. Events will be polled starting from this
   *     event id
   * @param eventPollingInterval HMS polling interval in seconds
   * @return this object is already created, or create a new one if it is not yet
   *     instantiated
   */
  public static synchronized MetastoreEventsProcessor getOrCreate(
      CatalogServiceCatalog catalog, long startSyncFromId, long eventPollingInterval) {
    if (INSTANCE != null) return INSTANCE;

    INSTANCE =
        new MetastoreEventsProcessor(catalog, startSyncFromId, eventPollingInterval);
    return INSTANCE;
  }

  public static MessageFactory getMessageFactory() { return messageFactory; }
}
