// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package org.apache.impala.catalog;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.util.concurrent.ThreadFactoryBuilder;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import org.apache.commons.lang3.StringUtils;
import org.apache.hadoop.hive.metastore.api.CurrentNotificationEventId;
import org.apache.hadoop.hive.metastore.api.Database;
import org.apache.hadoop.hive.metastore.api.NotificationEvent;
import org.apache.hadoop.hive.metastore.api.NotificationEventResponse;
import org.apache.hadoop.hive.metastore.messaging.MessageFactory;
import org.apache.hadoop.hive.metastore.messaging.json.ExtendedJSONMessageFactory;
import org.apache.hadoop.hive.metastore.messaging.json.JSONAlterDatabaseMessage;
import org.apache.hadoop.hive.metastore.messaging.json.JSONAlterTableMessage;
import org.apache.hadoop.hive.metastore.messaging.json.JSONCreateDatabaseMessage;
import org.apache.impala.catalog.MetaStoreClientPool.MetaStoreClient;
import org.apache.impala.common.ImpalaException;
import org.apache.impala.common.Reference;
import org.apache.impala.service.BackendConfig;
import org.apache.impala.thrift.TTableName;
import org.apache.log4j.Logger;
import org.apache.thrift.TException;

/**
 * A metastore event is a instance of the class
 * <code>org.apache.hadoop.hive.metastore.api.NotificationEvent</code>. Metastore can be configured,
 * to work with Listeners which are called on various DDL operations like create/alter/drop
 * operations on database, table, partition etc. Each event has a unique incremental id and the
 * generated events are be fetched from Metastore to get incremental updates to the metadata stored
 * in Hive metastore using the the public API <code>get_next_notification</code> These events could
 * be generated by external Metastore clients like Apache Hive or Apache Spark as well as other
 * Impala clusters configured to talk with the same metastore.
 *
 * This class is used to poll metastore for new events at a given frequency. By applying such events
 * on the catalogD we can sync to external metadata operations by taking appropriate actions for
 * each event type. We keep track of the last synced event id in each polling iteration so the next
 * batch can be requested appropriately. The current batch size is constant and set to
 * MAX_EVENTS.
 *
 * Following actions are currently taken based on the type of events received from
 * metastore.
 * <ul>
 *   <li>CREATE_TABLE, CREATE_DATABASE</li>
 *   A new table/database is created in Catalog respectively. The newly created table/database are
 *   Incomplete and should get loaded lazily when needed
 *   <li>DROP_TABLE, DROP_DATABASE</li>
 *   The table/database is dropped from catalog if they are present
 *   <li>ALTER_TABLE</li>
 *   In case of alter table event, currently the code issues a invalidate table command. There is a
 *   special case of this event in case of renames, where the old table is removed and a new
 *   IncompleteTable with the new name is created.
 *   <li>ALTER_DATABASE</li>
 *   In case of alter database events, currently only the case of changing default location, owner
 *   and change in database description is supported.
 *   <li>ADD_PARTITION, ALTER_PARTITION and DROP_PARTITION</li>
 *   Currently, in case of these events, we issue invalidate on the table. This can be optimized by
 *   issuing add/refresh/drop the partition at the Table level
 *   <li>CREATE_FUNCTION, DROP_FUNCTION, INSERT_EVENT</li>
 *   Currently, these events are ignored.
 * </ul>
 *
 */
class MetastoreEventsProcessor {
  private static final String METASTORE_NOTIFICATIONS_ADD_THRIFT_OBJECTS_CONFIG_KEY =
      "hive.metastore.notifications.add.thrift.objects";

  // keeps track of the last event id which we have synced to
  private long lastSyncedEventId_;

  private final CatalogServiceCatalog catalog_;
  private static final Logger LOG = Logger.getLogger(MetastoreEventsProcessor.class);

  private final ScheduledExecutorService scheduler_ =
      Executors.newSingleThreadScheduledExecutor(
          new ThreadFactoryBuilder()
              .setDaemon(true)
              .setNameFormat("MetastoreEventsProcessor")
              .build());

  // Use ExtendedJSONMessageFactory to deserialize the event messages.
  // ExtendedJSONMessageFactory adds additional information over JSONMessageFactory so
  // that events are compatible with Sentry
  // TODO this should be moved to JSONMessageFactory when Sentry switches to
  // JSONMessageFactory
  private static final MessageFactory messageFactory =
      ExtendedJSONMessageFactory.getInstance();
  private static MetastoreEventsProcessor INSTANCE;

  // maximum number of events to poll in each RPC
  private static final int EVENTS_BATCH_SIZE_PER_RPC = 1000;

  private MetastoreEventsProcessor(
      CatalogServiceCatalog catalog, long startSyncFromId, long pollingFrequencyInSec) {
    this.catalog_ = Preconditions.checkNotNull(catalog);
    // this assumes that when MetastoreEventsProcessor is created, catalogD just came
    // up in which case it already is going to do a full-sync with HMS
    // TODO figure out if CatalogD sync with HMS is in-process or completed so that we
    // know  if we need to ignore some of events which are already applied in catalogD
    lastSyncedEventId_ = startSyncFromId;
    // If the polling frequency is set to 0 don't schedule
    Preconditions.checkState(pollingFrequencyInSec >= 0);
    if (pollingFrequencyInSec > 0) {
      scheduleAtFixedDelayRate(pollingFrequencyInSec);
    }
  }

  /**
   * Schedules the daemon thread at a given frequency. It is important to note that this
   * method schedules with FixedDelay instead of FixedRate. The reason it is scheduled at
   * a fixedDelay is to make sure that we don't pile up the pending tasks in case each
   * polling operation is taking longer than the given frequency. Because of the fixed
   * delay, the new poll operation is scheduled at the time when previousPoll operation
   * completes + givenDelayInSec
   *
   * @param pollingFrequencyInSec Number of seconds at which the polling needs to be done
   */
  void scheduleAtFixedDelayRate(long pollingFrequencyInSec) {
    Preconditions.checkState(pollingFrequencyInSec > 0);
    LOG.info(String.format("Starting metastore event polling with interval %d seconds.",
        pollingFrequencyInSec));
    scheduler_.scheduleWithFixedDelay(() -> {
      try {
        processHMSNotificationEvents();
      } catch (ImpalaException e) {
        LOG.warn(String.format(
            "Unexpected exception %s received while processing metastore events",
            e.getMessage()), e);
      }
    }, pollingFrequencyInSec, pollingFrequencyInSec, TimeUnit.SECONDS);
  }

  /**
   * This method issues a request to Hive Metastore if needed, based on the current event
   * id in metastore and the last synced event_id. Events are fetched in fixed sized
   * batches.
   */
  @VisibleForTesting
  void processHMSNotificationEvents() throws ImpalaException {
    long currentEventId = -1;
    try (MetaStoreClient msClient = catalog_.getMetaStoreClient()) {
      // fetch the current notification event id. We assume that the polling interval is small
      // enough that most of these polling operations result in zero new events. In such a case,
      // fetching current notification event id is much faster (and cheaper on HMS side) instead
      // of polling for events directly
      CurrentNotificationEventId currentNotificationEventId =
          msClient.getHiveClient().getCurrentNotificationEventId();

      currentEventId = currentNotificationEventId.getEventId();
    } catch (TException e) {
      throw new MetastoreNotificationException(
          "Unable to fetch notifications from metastore. Last synced event id is "
              + lastSyncedEventId_, e);
    }
    if (currentEventId > lastSyncedEventId_) {
      NotificationEventResponse response = msClient.getHiveClient()
          .getNextNotification(lastSyncedEventId_, EVENTS_BATCH_SIZE_PER_RPC, null);
      LOG.info("Received " + response.getEvents().size() + " events. Start event id : "
          + lastSyncedEventId_);
      for (NotificationEvent event : response.getEvents()) {
        // update the lastSyncedEventId before processing the event itself
        try {
          processEvent(event);
        } catch (MetastoreNotificationException ex) {
          LOG.warn(String
              .format("Unable to process notification event %d due to %s. Ignoring this event...",
                  event.getEventId(), ex.getMessage()));
        } finally {
          // Make sure to update lastSyncedEventId_ in case there are errors while processing the
          // event. Otherwise, the sync thread will be stuck forever at this bad event and keep
          // throwing exception until catalogD is restarted
          lastSyncedEventId_ = event.getEventId();
        }
      }
    }
  }

  private void processEvent(NotificationEvent event) throws ImpalaException {
    LOG.info("Processing event " + event.getEventId() + " : " + event.getEventType()
        + " : " + event.getTableName());
    String tblName = event.getTableName();
    String dbName = event.getDbName();
    Db db = catalog_.getDb(dbName);
    Table table = (db != null && tblName != null) ? db.getTable(tblName) : null;
    switch (event.getEventType()) {
      case "ADD_PARTITION":
      case "ALTER_PARTITION":
      case "DROP_PARTITION":
        // TODO may be do a direct update using partition object here. See IMPALA-7973
        invalidateCatalogTable(table);
        break;
      case "CREATE_TABLE":
        catalog_.addTable(dbName, tblName);
        LOG.info(String.format("Added table %s.%s", dbName, tblName));
        break;
      case "ALTER_TABLE":
        // in case of table level alters from external systems it is better to do a full
        // invalidate  eg. this could be due to as simple as adding a new parameter or a
        // full blown adding  or changing column type
        // detect the special where a table is renamed
        if (!processRenameTableEvent(event)) {
          invalidateCatalogTable(table);
        }
        break;
      case "DROP_TABLE":
        catalog_.removeTable(dbName, tblName);
        LOG.info(String.format("Removed table %s.%s", dbName, tblName));
        break;
      case "CREATE_DATABASE":
        if (db == null) {
          LOG.info(String.format("Adding a new database %s", dbName));
        } else {
          LOG.info(String.format("Replacing existing database %s", dbName));
        }
        Database msDb = MetastoreEventsProcessor.getDatabaseFromMessage(event);
        catalog_.addDb(dbName, msDb);
        break;
      case "DROP_DATABASE":
        if (db != null) {
          catalog_.removeDb(dbName);
        }
        break;
      case "ALTER_DATABASE":
        // in case of alter_database there operations are limited to the database and not
        // cascaded down to the tables within the tables. Hence we don't need to remove
        // the database and add again
        // TODO need to fix HIVE bug while de-serializing alter_database event message
        /*if (db != null) {
          msDb = MetastoreEventsProcessor.getDatabaseFromMessage(event);
          db.setMSDb(msDb);
        }*/
        break;
      // TODO do we care about indexes?
      case "CREATE_INDEX":
      case "ALTER_INDEX":
      case "DROP_INDEX":
        // TODO function events are currently not supported
      case "CREATE_FUNCTION":
      case "ALTER_FUNCTION":
      case "DROP_FUNCTION":
      default: {
        LOG.warn(
            String.format("Unsupported event id %d of type %s received. Ignoring ...",
                event.getEventId(), event.getEventType()));
      }
    }
  }

  /**
   * If the ALTER_TABLE event is due a table rename, this method removes the old table and
   * creates a new table with the new name. //TODO Check if we can rename the existing
   * table in-place
   *
   * @return true if the event was rename event and remove of old table name and adding of
   * table with the new name is successful. Returns false, if the alter event is not for
   * rename operation
   */
  private boolean processRenameTableEvent(NotificationEvent event)
      throws MetastoreNotificationException {
    JSONAlterTableMessage alterTableMessage =
        (JSONAlterTableMessage) messageFactory.getDeserializer().getAlterTableMessage(
            event.getMessage());
    try {
      org.apache.hadoop.hive.metastore.api.Table oldTable =
          alterTableMessage.getTableObjBefore();
      org.apache.hadoop.hive.metastore.api.Table newTable =
          alterTableMessage.getTableObjAfter();
      if (oldTable.getDbName().equalsIgnoreCase(newTable.getDbName())
          && oldTable.getTableName().equalsIgnoreCase(newTable.getTableName())) {
        // table is not renamed, nothing to do
        return false;
      }
      // table was renamed, remove the old table
      LOG.info(String.format("Found that %s.%s table was renamed. Removing it",
          oldTable.getDbName(), oldTable.getTableName()));
      catalog_.removeTable(oldTable.getDbName(), oldTable.getTableName());
      catalog_.addTable(newTable.getDbName(), newTable.getTableName());
      return true;
    } catch (Exception e) {
      throw new MetastoreNotificationException(e);
    }
  }

  /**
   * Deserializes the event message and create a database object out of it.
   *
   * @param event a CREATE_DATABASE or ALTER_DATABASE event
   * @return Database object deserialized from event message
   */
  private static Database getDatabaseFromMessage(NotificationEvent event)
      throws MetastoreNotificationException {
    Preconditions.checkState("CREATE_DATABASE".equalsIgnoreCase(event.getEventType())
        || "ALTER_DATABASE".equalsIgnoreCase(event.getEventType()));
    Database msDb = null;
    try {
      if ("CREATE_DATABASE".equalsIgnoreCase(event.getEventType())) {
        JSONCreateDatabaseMessage createDatabaseMessage =
            (JSONCreateDatabaseMessage) messageFactory.getDeserializer()
                .getCreateDatabaseMessage(event.getMessage());
        msDb = createDatabaseMessage.getDatabaseObject();
      } else if ("ALTER_DATABASE".equalsIgnoreCase(event.getEventType())) {
        JSONAlterDatabaseMessage alterDatabaseMessage =
            (JSONAlterDatabaseMessage) messageFactory.getDeserializer()
                .getAlterDatabaseMessage(event.getMessage());
        msDb = alterDatabaseMessage.getDbObjAfter();
        Database msDbBefore = alterDatabaseMessage.getDbObjBefore();
        if (!checkSupportedCasesForAlterDatabaseEvent(msDbBefore, msDb)) {
          throw new MetastoreNotificationException(String.format(
              "Unsupported alter_database event received. "
                  + "Event id %d, Database before : %s, Database after : %s",
              event.getEventId(), msDbBefore, msDb));
        }
      }
      if (msDb == null) {
        throw new MetastoreNotificationException(String.format(
            "Database object is null in the event id %d : event message %s. "
                + "This could be a metastore configuration problem. "
                + "Check if %s is set to true in metastore configuration",
            event.getEventId(), event.getMessage(),
            METASTORE_NOTIFICATIONS_ADD_THRIFT_OBJECTS_CONFIG_KEY));
      }
      return msDb;
    } catch (Exception e) {
      throw new MetastoreNotificationException(e);
    }
  }

  /**
   * We support only the following alter_database conditions. 1. If the database
   * parameters are changed 2. If the database owner is changed 3. If the database
   * location is changed
   */
  private static boolean checkSupportedCasesForAlterDatabaseEvent(
      Database msDbBefore, Database msDbAfter) {
    Preconditions.checkNotNull(msDbBefore);
    Preconditions.checkNotNull(msDbAfter);
    return !StringUtils.equalsIgnoreCase(
               msDbAfter.getOwnerName(), msDbBefore.getOwnerName())
        || !StringUtils.equalsIgnoreCase(
               msDbAfter.getLocationUri(), msDbBefore.getLocationUri())
        || !(msDbAfter.isSetParameters()
               && msDbAfter.getParameters().equals(msDbBefore.getParameters()));
  }

  private void invalidateCatalogTable(Table table) {
    if (table == null) {
      return;
    }
    TTableName tTableName = table.getTableName().toThrift();
    Reference<Boolean> tblWasRemoved = new Reference<>();
    Reference<Boolean> dbWasAdded = new Reference<>();
    catalog_.invalidateTable(tTableName, tblWasRemoved, dbWasAdded);
    LOG.info("Table " + table.getTableName() + " in database " + table.getDb().getName()
        + " invalidated because the table was recreated in metastore");
  }

  /**
   * Create a instance of this object if it is not initialized. Currently, this object is
   * a singleton and should only be created during catalogD initialization time, so that
   * the start syncId matches with the catalogD startup time.
   *
   * @param catalog the CatalogServiceCatalog instance to which this event processing
   * belongs
   * @param startSyncFromId Start event id. Events will be polled starting from this event
   * id
   * @param config BackendConfiguration object to get the hms_event_polling_frequency_s
   * value
   * @return this object is already created, or create a new one if it is not yet
   * instantiated
   */
  public static synchronized MetastoreEventsProcessor getOrCreate(
      CatalogServiceCatalog catalog, long startSyncFromId, BackendConfig config) {
    if (INSTANCE == null) {
      INSTANCE = new MetastoreEventsProcessor(
          catalog, startSyncFromId, config.getHMSPollingFrequencyInSeconds());
    }
    return INSTANCE;
  }

  /**
   * Utility exception class to be thrown for errors during event processing
   */
  static class MetastoreNotificationException extends ImpalaException {
    public MetastoreNotificationException(String msg, Throwable cause) {
      super(msg, cause);
    }

    public MetastoreNotificationException(String msg) { super(msg); }

    public MetastoreNotificationException(Exception e) { super(e); }
  }
}
